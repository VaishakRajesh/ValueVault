# ValueVault — Full Project Explanation

A complete, developer-focused breakdown of the **ValueVault** auction platform. This document explains goals, architecture, data model, APIs, UX flows, implementation details, deployment, and operational notes in a clear step-by-step way so you can start building immediately.

---

# 1. Project Summary

**Purpose:**
ValueVault is an online auction platform for valuable and unique items (paintings, antiques, coins, collectibles, handmade pieces). Sellers list items; admins verify them; buyers compete with bids. The highest bidder wins and pays securely.

**Primary users:**

* **Sellers** — upload items and set an expected price.
* **Buyers** — browse auctions and place bids.
* **Admins** — verify listings, manage auctions and users.

**Core value:** Trust, transparency, and a real-time competitive bidding experience that helps sellers get the best market value for rare items.

---

# 2. High-level Architecture

* **Frontend:** Next.js (React) — SSR/SSG where appropriate, client-side for auction UI.
* **Backend / API:** Next.js API Routes (Node.js) + Prisma ORM.
* **Database:** PostgreSQL.
* **Real-time:** Socket.io or Pusher (for live bidding updates).
* **Image Storage:** Cloudinary (signed uploads) or Firebase Storage.
* **Payments:** Stripe (recommended) or Razorpay (India-friendly).
* **Authentication:** NextAuth.js (session-based) or JWT.

Deployment: Vercel for Next.js frontend/API, Railway/Fly/Heroku or DigitalOcean for Postgres if needed.

---

# 3. Modules & Responsibilities

## 3.1 Admin Module

* Review & approve/reject product listings.
* Start, pause, or end auctions (override automatic end if needed).
* View auction analytics & user reports.
* Manage users (suspend, verify, view history).
* Payment disputes & refunds handling.

## 3.2 Seller Module

* Create & manage product listings (title, desc, multiple images, expectedPrice, category, condition, provenance fields).
* See product status (Pending, Approved, Rejected).
* Monitor live auctions for their items.
* View sales history and payouts.

## 3.3 Buyer Module

* Browse/live-search auctions and filters (category, price range, ending soon).
* View auction page with current highest bid, time left, bid history.
* Place bids (client validates increment rules before sending).
* Receive notifications (outbid, win).

## 3.4 System (Background)

* Auction scheduler / worker that ends auctions, determines winners, creates orders and triggers payment flow or invoice.
* Webhook handlers for payment events.

---

# 4. Database Design (Prisma schema)

Use this `schema.prisma` as the starting point.

```prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String     @id @default(cuid())
  name      String
  email     String     @unique
  password  String
  role      Role       @default(USER)
  products  Product[]  @relation("UserProducts")
  bids      Bid[]
  orders    Order[]
  createdAt DateTime   @default(now())
}

model Product {
  id            String     @id @default(cuid())
  title         String
  description   String
  imageUrls     String[]   @default([])
  expectedPrice Float
  status        ProductStatus @default(PENDING)
  sellerId      String
  seller        User        @relation("UserProducts", fields: [sellerId], references: [id])
  auction       Auction?
  createdAt     DateTime   @default(now())
}

model Auction {
  id          String    @id @default(cuid())
  productId   String    @unique
  product     Product   @relation(fields: [productId], references: [id])
  startTime   DateTime
  endTime     DateTime
  status      AuctionStatus @default(ONGOING)
  bids        Bid[]
}

model Bid {
  id        String   @id @default(cuid())
  amount    Float
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  auctionId String
  auction   Auction  @relation(fields: [auctionId], references: [id])
  createdAt DateTime @default(now())
}

model Order {
  id        String   @id @default(cuid())
  productId String
  product   Product  @relation(fields: [productId], references: [id])
  buyerId   String
  buyer     User     @relation(fields: [buyerId], references: [id])
  total     Float
  status    OrderStatus @default(PENDING_PAYMENT)
  createdAt DateTime @default(now())
}

enum Role {
  USER
  ADMIN
}

enum ProductStatus {
  PENDING
  APPROVED
  REJECTED
}

enum AuctionStatus {
  ONGOING
  ENDED
}

enum OrderStatus {
  PENDING_PAYMENT
  PAID
  SHIPPED
  CANCELLED
  REFUNDED
}
```

Notes:

* `imageUrls` is an array of image links stored on Cloudinary.
* Keep indexes on `Auction.endTime` and `Bid.createdAt` for efficient queries.

---

# 5. API Design (Next.js API Routes)

Below are recommended API endpoints and a short spec.

## Auth

* `POST /api/auth/register` — register user (name, email, password).
* `POST /api/auth/login` — sign in (returns session or JWT).
* `GET /api/auth/me` — current user.
* `POST /api/auth/logout` — sign out.

## Products (Seller & Public)

* `POST /api/products` — create product (seller only). Body: title, description, expectedPrice, imageUrls, category.
* `GET /api/products` — list public products with filters and pagination.
* `GET /api/products/:id` — product details (includes current auction info if any).
* `PUT /api/products/:id` — seller edits product (if allowed).
* `DELETE /api/products/:id` — seller delete (if not in active auction).

## Admin Product Actions

* `POST /api/admin/products/:id/approve` — approve product and optionally create an auction.
* `POST /api/admin/products/:id/reject` — reject listing with a reason.

## Auction

* `POST /api/auctions` — create auction (admin or system) with productId, startTime, endTime.
* `GET /api/auctions` — list active/upcoming auctions.
* `GET /api/auctions/:id` — auction detail including bid history.
* `POST /api/auctions/:id/end` — force-end auction (admin).

## Bids

* `POST /api/auctions/:id/bids` — place a bid. Body: amount. (Server validates: amount > currentHighest + minIncrement, user balance, auction open.)
* `GET /api/auctions/:id/bids` — list bids (for auction page).

## Orders & Payments

* `POST /api/orders` — create order after auction ends (server-side).
* `POST /api/payments/create-session` — create Stripe checkout session for an order.
* `POST /api/payments/webhook` — Stripe webhook for payment events.

## Admin Analytics

* `GET /api/admin/metrics` — auctions, revenue, user growth.

Security: validate role (ADMIN vs USER) using middleware on admin endpoints.

---

# 6. Frontend Pages & Components

## Pages

* `/` — Landing page; featured & ending-soon auctions.
* `/auth/login` `/auth/register` — auth pages.
* `/products` — browsing & filtering.
* `/products/[id]` — product + auction page + bid form + history.
* `/sell/new` — seller product creation form.
* `/dashboard` — user dashboard (my listings, bids, purchases).
* `/admin` — admin dashboard for approval queue and metrics.

## Key Components

* `Navbar`, `Footer` — global.
* `ProductCard` — used in listings.
* `AuctionTimer` — countdown with auto-refresh.
* `BidForm` — validates min increment and funds.
* `BidHistoryList` — shows recent bids.
* `ImageUploader` — client-side signed upload support.

UX notes:

* Provide clear indicators when a product is `Pending` vs `Approved`.
* Show live highest bid and user’s own highest bid highlighted.
* Implement client-side optimistic updates with server confirmation.

---

# 7. Real-time Bidding

* Use Socket.io or a managed real-time service (Pusher, Ably).
* Events:

  * `bid:new` — broadcast new bid to subscribers of auction room.
  * `auction:ended` — notify clients auction ended and show winner.
  * `bid:outbid` — notify the outbid user (push/email).

Server-side flow when a bid is placed:

1. Client calls `POST /api/auctions/:id/bids`.
2. Server validates and writes `Bid` to DB.
3. Server emits `bid:new` (with new highest bid) to socket room `auction:<id>`.
4. Clients update UI.

To prevent race conditions, use DB transaction and serve `SELECT FOR UPDATE`-like semantics or optimistic concurrency: verify highest bid at write time and reject if stale.

---

# 8. Auction Lifecycle & Background Jobs

**Start auction:** Admin or workflow creates Auction row and sets `startTime` and `endTime`.

**During auction:** Bids are accepted while `now` is between start and end.

**Ending auction:** Implement a background worker (cron or scheduled job) that:

* Finds auctions where `endTime <= now AND status = ONGOING`.
* Fetches highest bid; marks auction `ENDED`.
* Creates an `Order` with `status = PENDING_PAYMENT` and notifies winner.
* Optionally triggers payment session creation.

**Anti-sniping (optional):** If a bid arrives within last N seconds (e.g., 60s), extend `endTime` by M seconds to allow counter-bids.

Tools for workers: Node schedule, BullMQ (Redis queue), or external cron with a serverless function.

---

# 9. Payments

Recommended: **Stripe Checkout + Webhooks**.

Flow:

1. Server creates `Order` after auction ends with `total = winningBid.amount`.
2. Server creates Stripe Checkout Session pointing to success/cancel URLs and sends sessionId to frontend.
3. Buyer completes payment via Stripe UI.
4. Stripe calls your `/api/payments/webhook` with `checkout.session.completed` event — verify signature and mark `Order.status = PAID`.
5. Trigger payout to seller (manual or automated depending on your policy).

Security:

* Verify Stripe webhook signatures.
* Do NOT trust client-side signals for payment completion.

Refunds & disputes: provide admin UI for initiating/refunding payments via Stripe Dashboard or API.

---

# 10. Image Uploads & Storage

* Use signed uploads to Cloudinary to avoid exposing API secrets to clients.
* Store only the final image URLs in `Product.imageUrls`.
* Validate file type, size, and run an image optimization pipeline (Cloudinary transformations) for thumbnails.

---

# 11. Authentication & Authorization

* Use NextAuth.js for session management and social logins (optional).
* Role-based guards: middleware to protect `/api/admin/*` and admin pages.
* Passwords: bcrypt hashing and secure storage.
* Consider email verification for higher trust.

---

# 12. Security Best Practices

* Use HTTPS & secure cookies.
* CSRF protection for form posts (NextAuth covers this for sessions).
* Input validation server-side (amount, email, text lengths).
* Rate limit `POST /bids` to prevent spam.
* Sanitize HTML in product descriptions to prevent XSS.
* Validate image content-type & size.

---

# 13. Indexing & Performance

* Add DB indexes on: `Auction.endTime`, `Bid.auctionId`, `Product.status`, `User.email`.
* Use CDN for images and static assets.
* Cache frequent read endpoints (e.g., public auctions) with short TTL.
* Use connection pooling for Postgres (e.g., PgBouncer) if scaling.

---

# 14. Testing & QA

* Unit tests: Jest + React Testing Library for React components.
* API tests: Supertest or integration tests against a test Postgres DB.
* End-to-end: Playwright or Cypress to test bidding and payment flows.
* Load testing: k6 for traffic simulation on auction pages.

---

# 15. Dev Setup & Commands

```bash
# clone
git clone https://github.com/yourusername/valuevault.git
cd valuevault

# install
npm install

# create .env (see Appendix)
cp .env.example .env

# prisma migrations
npx prisma migrate dev --name init
npx prisma generate

# seed (create sample users/products)
npm run seed

# run dev server
npm run dev
```

---

# 16. Deployment Notes

* Use Vercel for Next.js with serverless API routes. For WebSockets and background workers, consider a dedicated server (DigitalOcean, Render, or Fly) or use managed services (Pusher, Ably).
* Host Postgres on Railway, ElephantSQL, or AWS RDS.
* Store env vars securely on Vercel / hosting platform.
* Use Stripe keys and configure webhook endpoint on your deployment domain.

---

# 17. Operational Checklist (Before Launch)

* [ ] Seed data (sample auctions & users).
* [ ] Admin account created and tested.
* [ ] Stripe test mode integration & webhook verified.
* [ ] Cloudinary upload workflow tested.
* [ ] Background worker to end auctions configured and running.
* [ ] Load test for peak auction pages.
* [ ] Security review completed.

---

# 18. Edge Cases & Business Rules

* **Minimum bid increment:** e.g., 5% of current highest or fixed steps.
* **Reserve vs expected price:** expectedPrice is visible; reserve can be hidden — auction only sells if reserve met.
* **Ties:** If two identical bids arrive at same amount, earliest timestamp wins.
* **Last-second bids:** implement anti-sniping extension rule.
* **Cancellation:** Admin can cancel an auction; refunds handled via Stripe.

---

# 19. Future Enhancements

* Two-factor authentication (2FA).
* Seller verification badges & KYC for high-value sales.
* Escrow system for holding buyer funds until confirmation.
* Mobile app (React Native).
* Machine-learning price suggestions for sellers.

---

# 20. Appendix — Example .env (local)

```
DATABASE_URL=postgresql://postgres:password@localhost:5432/valuevault
NEXTAUTH_SECRET=replace_with_random
CLOUDINARY_CLOUD_NAME=your_cloud_name
CLOUDINARY_API_KEY=your_cloud_key
CLOUDINARY_API_SECRET=your_cloud_secret
STRIPE_SECRET_KEY=sk_test_...
STRIPE_WEBHOOK_SECRET=whsec_...
```

---

# 21. Appendix — Useful Commands (Prisma)

```
# create migration & apply
npx prisma migrate dev --name init

# generate client
npx prisma generate

# open studio (GUI)
npx prisma studio
```
11-8-25
create app
create folders and page like admin ,user homepage like that
create logo and other thing on front homepage now working on landing homepage